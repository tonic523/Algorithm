# [lcs](https://www.acmicpc.net/problem/9251)

## 풀이1
- 실패

> 2중 for문으로 풀리지 않을까?

두 문자열을 이중 for문으로 순회하면 풀릴 것 같았습니다.\
- 첫 번째 문자열을 순회한다.
- 첫 번째 문자열의 문자를 두 번째 문자열에서 순회하고 아래의 조건을 수행
  - 있다면 해당 문자의 위치+1 을 반환
  - 없다면 위치 고정
- 두 번재 문자를 순회할 때 방금 구한 위치 부터 두 번째 문자열을 순회한다.

위 과정을 반복한 횟수를 반환하면 풀릴 줄 알았지만 .. \
실패했습니다.\
다시 생각해보면 예를 들어\
- ABABABABAB
- BABABAABAB

위에서 결과는 9 (BABABABAB)이지만 위 풀이 방법은 8이 나옵니다.\
이유는 문자열이 없을 때 위치가 고정이 되는데 이는 다음 순회할 문자가\
그 다음 위치에 있더라도 패스하기 때문입니다.

> 힌트: 다이나믹 프로그래밍

도저히 감을 잡지 못해 결국 구글링에 손을 댔습니다..\
dp로 푼다는 힌트를 보고 도저히 감을 잡지 못하다가 점화식과\
2중 배열의 dp 테이블을 보고 깨달았습니다!
- 점화식 : s1[i] == s2[j] -> dp[i][j] = dp[i-1][j-1] + 1
- s1[i] != s2[j] -> dp[d_i][d_j] = max(*[dp[d_i-1][d_j-1], dp[d_i][d_j-1], dp[d_i-1][d_j]])

위 점화식의 뜻은 만약 i번째 문자와 j번째 문자가 같다면\
i-1까지의 문자열과 j-1까지의 문자열의 lcs 값과 같다는 뜻입니다.\
다르다면 위 3가지 방법 중 가장 큰 값과 같다는 뜻입니다.\
dp를 활용하는 것과 점화식을 떠올리는 아이디어, 머리가 있다면\
쉽게 풀 수 있는 문제였습니다.