# [N과 M (12)](https://www.acmicpc.net/problem/15666)

## 풀이1

문제를 보고 중복 조합을 구현하는 문제라고 생각했습니다.\
[1, 2] 에서 길이가 2인 수열을 모두 구한다고 한다면\
- 1 1
- 1 2
- 2 2

3가지가 나올 수 있습니다.\
[1, 2, 2] 에서 똑같이 길이가 2인 수열을 구한다고 했을 때에도
- 1 1
- 1 2
- 2 2

처럼 똑같기 때문에 우선 입력된 숫자들의 중복을 제거해줬습니다.(집합 자료형으로)\
이 문제에서는 1 2 와 2 1을 중복된 수열로 보기 때문에 이 중복도 제거해주는 구현이 필요합니다.\
저는 다음과 같이 구현했습니다.
1. 주어진 숫자 배열을 정렬 후 집합 자료형으로 중복 제거
2. 숫자 배열을 첫 번째 원소부터 하나씩 고른다.
3. 첫 번째 원소를 숫자 배열에서 0 인덱스부터 접근해 순차적으로 고른다.(0 ~ N-1)
4. 첫 번째 원소를 숫자 배열 중 n번째 숫자를 골랐다고 했을 때 두 번째 원소는 (n ~ N-1)을 고른다.
5. M만큼 골랐다면 출력하고 해당 배열을 문자열로 바꿔 방문 리스트에 추가한다.

4번 처럼 구현한 이유는\
[1, 2] 에서 2개를 고른 수열을 구한다고 했을 때
첫 번째 원소 // 두 번째 원소
- 1 // 1
- 1 // 2 (중복)
- 2 // 1 (중복)
- 2 // 2

중복된 수열이 생깁니다. 이 중복이 생기는 이유는 1을 첫 번째 뽑았을 때와 두 번째 뽑았을 때 같은 값이 나오기 때문입니다.\
따라서 만약 첫 번째 원소를 숫자 배열에서 1 인덱스인 2값을 뽑았다면 두 번째 원소를 고를 땐 뽑은 인덱스보다 작은 인덱스 값을 고르지 않는다면\
중복을 피할 수 있습니다.\
그런데 이유는 아직 모르겠지만 통과가 되진 못했습니다 ..

## 풀이2

위와 비슷한 구현이라고 생각되는 다른 방법으로 풀이했습니다.\
위에서는 리스트에 접근하는 인덱스로 중복을 피했다면 이 방법은 사실 리스트를 내림차순으로 정렬했기 때문에\
숫자의 크기를 비교해서 구현할 수 있습니다.\
따라서 현재 고를 숫자가 전에 고른 숫자보다 작거나 크면 고르고 아니면 고르지 않게 구현한다면 풀이가 가능합니다.
