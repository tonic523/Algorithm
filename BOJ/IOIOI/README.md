# [IOIOI](https://www.acmicpc.net/problem/5525)

## 풀이1

- 부분 성공(50점)

> 풀이 과정

입력된 문자열을 순회하면서 I가 나왔을 때 다음의 조건을 만족하면 결과값에 1을 추가합니다.
- I가 나온 인덱스 부터 비교하려는 문자열의 길이를 더한 값까지 비교하여 맞으면 +1을 합니다.

위 처럼 푸는 방식이 틀린 이유는 문자열의 길이에 제약 조건이 없기 때문에 문자열의 길이가 매우 길어지면 그만큼 시간복잡도가 커져서 부분점수를 받은 것 같습니다.

## 풀이 2

- 완전 성공(100점)

> 풀이 과정

위에서 이중 for문으로 돌아서 50점이 나왔기 때문에 문자열을 한번만 순회하는 방법을 고민했습니다.\
for문을 돌면서 I가 나오면 start를 True로 바꾸어 IOIOI 순으로 문자열이 있는지 확인하는 조건식을 실행합니다.\
- 전에 순회했던 값이 I이면 O인지 확인, O이면 I인지 확인
- I여야 하는데 O가 나오면 지금까지 센 cnt 값의 -1한 값을 결과 리스트에 추가
- O여야 하는데 I이면 cnt 값을 결과 리스트에 추가
이 후에 결과 리스트를 순회하여 Pn의 길이보다 크면 아래의 식을 실행하여 값을 추가
- 결과 리스트 중 하나의 값 = t
- (t - Pn) // 2 + 1

## 풀이 3

- 완전 성공(100점)

> 풀이 과정

위에서는 IOIO의 반복과정을 조건식으로 맞으면 그 문자열을 리스트에 담고 리스트의 값들을 순회하여 결과값을 도출했다면\
여기서는 "IOI" 를 한번 순회할 때 3개의 문자를 한번에 점검하는 방법입니다.\
- `i-1 == "I"` `i == "O"` `i+1 == "I'` 이면 패턴이 한번 일치함으로 패턴의 값에 1을 더합니다.
  - 이 후 만약 패턴의 값이 N과 같다면 answer에 값을 추가하고 패턴에 1을 빼줍니다.
  - 이 조건이 실행되면 인덱스에 +1을 해주어 밑에 인덱스 +1과 중첩되어 인덱스+2를 검사합니다.
- 만약 첫 번째 조건이 아니라면 패턴의 값은 0으로 해주고 바로 다음 인덱스 +1을 검사합니다.
